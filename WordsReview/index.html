<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配对挑战 - 带错题统计</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <style type="text/tailwindcss">
        @layer utilities {
            .btn-selected {
                @apply bg-emerald-500 transform scale-105;
            }
            .btn-disabled {
                @apply bg-gray-500 opacity-10 cursor-not-allowed;
            }
            .strikethrough {
                text-decoration: line-through;
            }
            .btn-error {
                @apply bg-rose-500;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 min-h-screen flex flex-col items-center justify-center p-4 text-white">
    <!-- 主容器 -->
    <div class="max-w-4xl w-full mx-auto flex flex-col items-center">
        <!-- 文件选择界面 -->
        <div id="file-upload-section" class="text-center p-8 w-full">
            <h1 class="text-3xl font-bold mb-8 text-cyan-300">
                <i class="fa fa-puzzle-piece mr-2"></i>配对挑战
            </h1>
            <p class="text-gray-300 mb-6 text-lg">请选择一个CSV格式文件开始游戏（每行包含两列，用逗号分隔）</p>
            
            <label for="file-upload" class="cursor-pointer inline-block">
                <div class="bg-slate-700 hover:bg-emerald-600 transition-all duration-300 py-6 px-10 rounded-lg shadow-lg inline-flex items-center justify-center">
                    <i class="fa fa-file-text-o mr-3 text-xl"></i>
                    <span class="text-lg font-medium">选择CSV文件</span>
                </div>
                <input id="file-upload" type="file" accept="text/csv" class="hidden">
            </label>
            
            <div id="file-upload-status" class="mt-6 hidden"></div>
            <div id="file-upload-error" class="mt-6 text-red-400 hidden"></div>
        </div>

        <!-- 游戏界面（默认隐藏） -->
        <div id="game-section" class="hidden w-full">
            <h1 class="text-3xl font-bold mb-8 text-center text-cyan-300">
                <i class="fa fa-puzzle-piece mr-2"></i>配对挑战
            </h1>
            
            <div class="flex flex-col md:flex-row gap-8 w-full">
                <div class="column flex-1 flex flex-col gap-3" id="left-column"></div>
                <div class="column flex-1 flex flex-col gap-3" id="right-column"></div>
            </div>
            
            <div id="status" class="mt-8 text-lg font-medium text-center"></div>
            <div id="progress" class="mt-4 text-sm text-center text-gray-300"></div>
            <div id="error" class="mt-4 text-red-400 text-center hidden"></div>
        </div>

        <!-- 错题统计界面（默认隐藏） -->
        <div id="error-summary-section" class="hidden w-full p-6 bg-slate-800 rounded-lg shadow-xl mt-8">
            <h2 class="text-2xl font-bold mb-6 text-center text-cyan-300">
                <i class="fa fa-bar-chart mr-2"></i>练习总结
            </h2>
            
            <div id="summary-stats" class="mb-8 text-center"></div>
            
            <div id="no-errors-message" class="text-center text-emerald-400 text-lg hidden">
                <i class="fa fa-check-circle mr-2"></i>恭喜！您没有错题！
            </div>
            
            <div id="errors-list-container" class="hidden">
                <h3 class="text-xl font-semibold mb-4 text-amber-300 border-b border-amber-500 pb-2">
                    错题记录
                </h3>
                <div id="errors-list" class="space-y-4 max-h-96 overflow-y-auto pr-2"></div>
            </div>
            
            <div class="mt-8 text-center">
                <button id="restart-button" class="bg-emerald-600 hover:bg-emerald-500 transition-all duration-300 py-3 px-8 rounded-lg text-white font-medium hidden">
                    <i class="fa fa-refresh mr-2"></i>重新开始
                </button>
                <button id="review-errors-button" class="bg-amber-600 hover:bg-amber-500 transition-all duration-300 py-3 px-8 rounded-lg text-white font-medium hidden">
                    <i class="fa fa-repeat mr-2"></i>复习错题
                </button>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let dataArray = [];           // 所有数据
        let currentItems = [];        // 当前轮次的题目
        let usedItems = new Set();    // 已经使用过的项目ID
        let currentRoundWrongItems = new Set(); // 本轮出现的错题
        let allTimeWrongItems = new Map(); // 所有时间的错题及错误次数 (id => count)
        let allItemsProcessed = false;// 所有项目是否已处理完毕
        let inReviewMode = false;     // 是否处于错题复习模式
        let clickHistory = [];        // 记录点击历史
        let matchedPairs = 0;         // 当前轮次已匹配的对数
        let totalItemsCount = 0;      // 总项目数量
        const ITEMS_PER_ROUND = 4;    // 每页显示4对题目

        // 事件监听
        document.getElementById('file-upload').addEventListener('change', handleFileUpload);
        document.getElementById('restart-button').addEventListener('click', restartGame);
        document.getElementById('review-errors-button').addEventListener('click', reviewErrors);

        // 重新开始游戏
        function restartGame() {
            // 重置所有游戏状态
            dataArray = [];
            currentItems = [];
            usedItems = new Set();
            currentRoundWrongItems = new Set();
            allTimeWrongItems = new Map();
            allItemsProcessed = false;
            inReviewMode = false;
            clickHistory = [];
            matchedPairs = 0;
            totalItemsCount = 0;

            // 隐藏总结界面，显示文件选择界面
            document.getElementById('error-summary-section').classList.add('hidden');
            document.getElementById('file-upload-section').classList.remove('hidden');
            document.getElementById('file-upload').value = ''; // 重置文件选择
        }

        // 复习错题
        function reviewErrors() {
            // 重置当前轮次状态，但保留所有错题记录
            currentRoundWrongItems = new Set();
            currentItems = [];
            matchedPairs = 0;
            inReviewMode = true; // 强制进入错题复习模式
            
            // 隐藏总结界面，显示游戏界面
            document.getElementById('error-summary-section').classList.add('hidden');
            document.getElementById('game-section').classList.remove('hidden');
            
            // 开始新一轮（错题复习）
            startNewRound();
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // 验证文件类型
            if (!file.name.endsWith('.csv')) {
                showFileError('请选择CSV格式的文件');
                return;
            }

            // 读取文件
            const reader = new FileReader();
            showFileStatus('正在读取文件...');

            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    parseCsvData(content);
                    showFileStatus('文件读取成功，正在准备游戏...');
                    
                    // 隐藏文件上传界面，显示游戏界面
                    setTimeout(() => {
                        document.getElementById('file-upload-section').classList.add('hidden');
                        document.getElementById('game-section').classList.remove('hidden');
                        startNewRound();
                    }, 1000);
                } catch (error) {
                    showFileError(`文件解析错误: ${error.message}`);
                }
            };

            reader.onerror = function() {
                showFileError('文件读取失败，请重试');
            };

            reader.readAsText(file);
        }

        // 显示文件上传状态
        function showFileStatus(message) {
            const statusEl = document.getElementById('file-upload-status');
            const errorEl = document.getElementById('file-upload-error');
            
            statusEl.textContent = message;
            statusEl.classList.remove('hidden', 'text-red-400');
            statusEl.classList.add('text-emerald-400');
            errorEl.classList.add('hidden');
        }

        // 显示文件上传错误
        function showFileError(message) {
            const statusEl = document.getElementById('file-upload-status');
            const errorEl = document.getElementById('file-upload-error');
            
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            statusEl.classList.add('hidden');
            
            // 重置文件输入，允许重新选择同一文件
            document.getElementById('file-upload').value = '';
        }

        // 解析CSV数据
        function parseCsvData(content) {
            dataArray = [];
            const lines = content.trim().split('\n');
            
            if (lines.length === 0) {
                throw new Error('文件内容为空');
            }

            lines.forEach((line, index) => {
                const parts = line.trim().split(',').map(part => part.trim());
                if (parts.length < 2) {
                    throw new Error(`第${index + 1}行格式错误，需要至少两列数据`);
                }
                
                const left = parts[0];
                const right = parts.slice(1).join(','); // 允许右侧内容包含逗号
                
                dataArray.push({
                    id: generateId(left, right),
                    left,
                    right
                });
            });

            if (dataArray.length === 0) {
                throw new Error('未找到有效的数据，请检查文件格式');
            }

            totalItemsCount = dataArray.length;
        }

        // 生成唯一ID用于跟踪项目
        function generateId(left, right) {
            return `${left}|${right}`;
        }

        // 显示错误信息
        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => {
                errorEl.classList.add('hidden');
            }, 3000);
        }

        // 开始新一轮游戏
        function startNewRound() {
            const leftColumn = document.getElementById('left-column');
            const rightColumn = document.getElementById('right-column');
            
            // 重置当前轮次状态，但保留上一轮的错题
            const previousWrongItems = new Set(currentRoundWrongItems);
            currentRoundWrongItems.clear();
            
            leftColumn.innerHTML = '';
            rightColumn.innerHTML = '';
            clickHistory = [];
            matchedPairs = 0;
            currentItems = [];

            // 检查是否所有题目都已处理完毕且没有错题
            if (usedItems.size >= totalItemsCount && !inReviewMode && previousWrongItems.size === 0) {
                showErrorSummary();
                return;
            }

            // 检查是否需要进入错题复习模式
            if (usedItems.size >= totalItemsCount && !inReviewMode) {
                inReviewMode = true;
                usedItems.clear(); // 重置已使用项目，只复习错题
                updateStatus('所有题目已完成，进入错题复习模式...');
            }

            // 获取当前轮次要使用的项目（包含上一轮的错题）
            getCurrentRoundItems(previousWrongItems);
            
            // 如果当前轮次没有题目，说明所有内容已完成
            if (currentItems.length === 0) {
                showErrorSummary();
                return;
            }
            
            // 生成左侧按钮
            currentItems.forEach(item => {
                const button = createButton(item.left, 'left', item.right, item.id);
                leftColumn.appendChild(button);
            });

            // 生成右侧按钮（确保不会与左侧同位置按钮匹配，除非只有一道题）
            let rightItems;
            if (currentItems.length === 1) {
                // 最后一轮只有一道题时，直接使用
                rightItems = [...currentItems];
            } else {
                // 否则，生成不会与左侧同位置匹配的排列
                rightItems = generateNonMatchingRightItems([...currentItems]);
            }
            
            rightItems.forEach(item => {
                const button = createButton(item.right, 'right', item.right, item.id);
                rightColumn.appendChild(button);
            });

            // 更新进度显示
            updateProgress(previousWrongItems);
            updateStatus(inReviewMode
                ? `错题复习: ${matchedPairs} / ${currentItems.length} 对`
                : `当前轮次: ${matchedPairs} / ${currentItems.length} 对`);
        }

        // 显示错题总结
        function showErrorSummary() {
            // 隐藏游戏界面，显示总结界面
            document.getElementById('game-section').classList.add('hidden');
            const summarySection = document.getElementById('error-summary-section');
            summarySection.classList.remove('hidden');

            // 计算统计数据
            const totalErrors = Array.from(allTimeWrongItems.values()).reduce((sum, count) => sum + count, 0);
            const uniqueErrors = allTimeWrongItems.size;

            // 更新统计信息
            const statsEl = document.getElementById('summary-stats');
            statsEl.innerHTML = `
                <p class="text-lg mb-2">总题目数量: <span class="text-cyan-300">${totalItemsCount}</span></p>
                <p class="text-lg mb-2">总错误次数: <span class="text-rose-300">${totalErrors}</span></p>
                <p class="text-lg">不同的错题数量: <span class="text-amber-300">${uniqueErrors}</span></p>
            `;

            // 显示或隐藏错题列表
            const noErrorsEl = document.getElementById('no-errors-message');
            const errorsContainerEl = document.getElementById('errors-list-container');
            const errorsListEl = document.getElementById('errors-list');
            const restartBtn = document.getElementById('restart-button');
            const reviewBtn = document.getElementById('review-errors-button');

            if (uniqueErrors === 0) {
                // 没有错题的情况
                noErrorsEl.classList.remove('hidden');
                errorsContainerEl.classList.add('hidden');
                restartBtn.classList.remove('hidden');
                reviewBtn.classList.add('hidden');
            } else {
                // 有错题的情况
                noErrorsEl.classList.add('hidden');
                errorsContainerEl.classList.remove('hidden');
                restartBtn.classList.add('hidden');
                reviewBtn.classList.remove('hidden');
                errorsListEl.innerHTML = '';

                // 按错误次数排序（从高到低）
                const sortedErrors = Array.from(allTimeWrongItems.entries())
                    .sort((a, b) => b[1] - a[1]);

                // 生成错题列表
                sortedErrors.forEach(([id, count]) => {
                    const item = dataArray.find(i => i.id === id);
                    if (item) {
                        const errorItem = document.createElement('div');
                        errorItem.className = 'bg-slate-700 p-4 rounded-lg shadow';
                        errorItem.innerHTML = `
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="font-medium"> <span class="text-cyan-300">${item.left}</span></p>
                                    <p class="mt-1"><span class="text-emerald-300">${item.right}</span></p>
                                </div>
                                <div class="bg-rose-600 text-white text-sm px-3 py-1 rounded-full">
                                    错误 ${count} 次
                                </div>
                            </div>
                        `;
                        errorsListEl.appendChild(errorItem);
                    }
                });
            }
        }

        // 生成右侧按钮数组，确保不会与左侧同位置按钮匹配
        function generateNonMatchingRightItems(items) {
            let shuffled = [...items];
            
            // 检查随机排列是否存在同位置匹配
            function hasSamePositionMatches(arr) {
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i].id === items[i].id) {
                        return true;
                    }
                }
                return false;
            }
            
            // 随机法：随机打乱，直到不存在同位置匹配，或尝试次数过多则强制调整
            let attempts = 0;
            while (hasSamePositionMatches(shuffled) && attempts < 100) {
                shuffled = shuffled.sort(() => Math.random() - 0.5);
                attempts++;
            }
            
            // 如果尝试多次后仍有同位置匹配，则手动调整
            if (hasSamePositionMatches(shuffled)) {
                for (let i = 0; i < shuffled.length; i++) {
                    if (shuffled[i].id === items[i].id) {
                        // 找到一个不同的位置进行交换
                        for (let j = 0; j < shuffled.length; j++) {
                            if (j !== i && shuffled[j].id !== items[i].id && shuffled[i].id !== items[j].id) {
                                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                                break;
                            }
                        }
                    }
                }
            }
            
            return shuffled;
        }

        // 获取当前轮次要使用的项目（包含上一轮的错题）
        function getCurrentRoundItems(previousWrongItems) {
            // 首先添加上一轮的所有错题
            const wrongItemsArray = Array.from(previousWrongItems).map(id => {
                return dataArray.find(item => item.id === id);
            });

            wrongItemsArray.forEach(item => {
                if (item && !currentItems.some(i => i.id === item.id)) {
                    currentItems.push(item);
                }
            });

            // 如果是复习模式，只使用错题
            if (inReviewMode) {
                // 从所有错题中选择，直到满4道
                const allWrongItems = Array.from(allTimeWrongItems.keys()).map(id => {
                    return dataArray.find(item => item.id === id);
                }).filter(Boolean);
                
                const remainingSlots = ITEMS_PER_ROUND - currentItems.length;
                if (remainingSlots > 0) {
                    const availableItems = allWrongItems.filter(item =>
                        !currentItems.some(i => i.id === item.id)
                    );
                    
                    const itemsToAdd = Math.min(remainingSlots, availableItems.length);
                    for (let i = 0; i < itemsToAdd; i++) {
                        const randomIndex = Math.floor(Math.random() * availableItems.length);
                        const randomItem = availableItems.splice(randomIndex, 1)[0];
                        
                        currentItems.push(randomItem);
                    }
                }
                return;
            }

            // 补充新题目直到满4道或没有更多新题
            const remainingSlots = ITEMS_PER_ROUND - currentItems.length;
            if (remainingSlots > 0) {
                const availableItems = dataArray.filter(item =>
                    !usedItems.has(item.id) && !currentItems.some(i => i.id === item.id)
                );
                
                const itemsToAdd = Math.min(remainingSlots, availableItems.length);
                for (let i = 0; i < itemsToAdd; i++) {
                    const randomIndex = Math.floor(Math.random() * availableItems.length);
                    const randomItem = availableItems.splice(randomIndex, 1)[0];
                    
                    currentItems.push(randomItem);
                    usedItems.add(randomItem.id);
                }
            }
        }

        // 更新进度显示
        function updateProgress(previousWrongItems) {
            const progressEl = document.getElementById('progress');
            
            if (inReviewMode) {
                const totalWrongItems = allTimeWrongItems.size;
                progressEl.textContent = `错题复习: 共 ${totalWrongItems} 道错题`;
            } else {
                const completedCount = usedItems.size - previousWrongItems.size;
                if (previousWrongItems.size > 0) {
                    progressEl.textContent = `总进度: ${completedCount}/${totalItemsCount} 已完成，本轮包含 ${previousWrongItems.size} 道上轮错题`;
                } else {
                    progressEl.textContent = `总进度: ${completedCount}/${totalItemsCount} 已完成`;
                }
            }
        }

        // 更新状态信息
        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = inReviewMode
                ? 'mt-8 text-lg font-medium text-center text-amber-300'
                : 'mt-8 text-lg font-medium text-center text-cyan-200';
        }

        // 创建按钮通用函数
        function createButton(text, type, match, itemId) {
            const button = document.createElement('button');
            // 基础样式
            button.className = 'py-4 px-6 rounded-lg bg-slate-700 transition-all duration-300 text-lg font-medium shadow-md hover:shadow-lg w-full hover:bg-emerald-600';
            button.textContent = text;
            button.dataset.type = type;
            button.dataset.match = match;
            button.dataset.itemId = itemId;
            button.addEventListener('click', handleClick);
            return button;
        }

        // 点击事件处理
        function handleClick(e) {
            if (allItemsProcessed) return;
            
            const currentBtn = e.target;
            if (currentBtn.classList.contains('btn-disabled')) return;

            // 清除所有按钮的错误状态
            document.querySelectorAll('.btn-error').forEach(btn => {
                btn.classList.remove('btn-error');
            });

            // 记录当前点击
            clickHistory.push(currentBtn);
            if (clickHistory.length > 2) clickHistory.shift();

            // 更新选中状态
            document.querySelectorAll('.btn-selected').forEach(btn => {
                btn.classList.remove('btn-selected');
            });
            currentBtn.classList.add('btn-selected');

            // 处理两次点击的配对逻辑
            if (clickHistory.length === 2) {
                const [firstBtn, secondBtn] = clickHistory; // 明确区分第一次和第二次点击
                const isDifferentColumns = firstBtn.dataset.type !== secondBtn.dataset.type;
                const isMatch = firstBtn.dataset.match === secondBtn.dataset.match;
                const firstItemId = firstBtn.dataset.itemId;  // 第一次点击的项目ID
                
                if (isDifferentColumns) {
                    if (isMatch) {
                        // 匹配成功
                        firstBtn.classList.add('btn-disabled', 'bg-emerald-600', 'strikethrough');
                        secondBtn.classList.add('btn-disabled', 'bg-emerald-600', 'strikethrough');
                        // 移除悬停效果
                        firstBtn.classList.remove('hover:bg-emerald-600', 'btn-selected');
                        secondBtn.classList.remove('hover:bg-emerald-600', 'btn-selected');
                        
                        firstBtn.removeEventListener('click', handleClick);
                        secondBtn.removeEventListener('click', handleClick);
                        
                        matchedPairs++;
                        updateStatus(inReviewMode
                            ? `错题复习: ${matchedPairs} / ${currentItems.length} 对`
                            : `当前轮次: ${matchedPairs} / ${currentItems.length} 对`);
                        clickHistory = [];

                        // 当前轮次完成，准备下一轮
                        if (matchedPairs === currentItems.length) {
                            const statusMessage = currentRoundWrongItems.size > 0
                                ? (inReviewMode
                                    ? `本轮复习完成！下一轮将包含 ${currentRoundWrongItems.size} 道仍出错的题目`
                                    : `本轮完成！下一轮将包含 ${currentRoundWrongItems.size} 道错题`)
                                : (inReviewMode
                                    ? '本轮复习完成！所有错题都已正确匹配！'
                                    : '本轮完成！准备下一轮新题目...');
                            
                            updateStatus(statusMessage);
                            setTimeout(() => startNewRound(), 1500);
                        }
                    } else {
                        // 匹配失败 - 第一次点击的按钮内容定义为错题
                        firstBtn.classList.add('btn-error');
                        secondBtn.classList.add('btn-error');
                        
                        // 记录错题，更新错误次数
                        currentRoundWrongItems.add(firstItemId);
                        if (allTimeWrongItems.has(firstItemId)) {
                            allTimeWrongItems.set(firstItemId, allTimeWrongItems.get(firstItemId) + 1);
                        } else {
                            allTimeWrongItems.set(firstItemId, 1);
                        }
                        
                        setTimeout(() => {
                            firstBtn.classList.remove('btn-error', 'btn-selected');
                            secondBtn.classList.remove('btn-error', 'btn-selected');
                            clickHistory = [];
                        }, 800);
                    }
                } else {
                    // 同一列点击，只保留当前点击的选中状态
                    firstBtn.classList.remove('btn-selected');
                }
            }
        }
    </script>
</body>
</html>
    