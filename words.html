<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配对挑战 - 带数据统计</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <style type="text/tailwindcss">
        @layer utilities {
            .btn-selected {
                @apply bg-emerald-500 transform scale-105;
            }
            .btn-disabled {
                @apply bg-gray-500 opacity-50 cursor-not-allowed;
            }
            .strikethrough {
                text-decoration: line-through;
            }
            .btn-error {
                @apply bg-rose-500;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 min-h-screen flex flex-col items-center justify-center p-4 text-white">
    <!-- 主容器 -->
    <div class="max-w-4xl w-full mx-auto flex flex-col items-center">
        <!-- 文件选择界面 -->
        <div id="file-upload-section" class="text-center p-8 w-full hidden">
            <h1 class="text-3xl font-bold mb-8 text-cyan-300">
                <i class="fa fa-puzzle-piece mr-2"></i>配对挑战
            </h1>
            <p class="text-gray-300 mb-6 text-lg">请选择一个CSV格式文件开始游戏（每行包含两列，用逗号分隔）</p>
            
            <label for="file-upload" class="cursor-pointer inline-block">
                <div class="bg-slate-700 hover:bg-emerald-600 transition-all duration-300 py-6 px-10 rounded-lg shadow-lg inline-flex items-center justify-center">
                    <i class="fa fa-file-text-o mr-3 text-xl"></i>
                    <span class="text-lg font-medium">选择CSV文件</span>
                </div>
                <input id="file-upload" type="file" accept="text/csv" class="hidden">
            </label>
            
            <div class="mt-6 flex justify-center gap-4">
                <button id="load-saved-words" class="bg-blue-600 hover:bg-blue-500 transition-all duration-300 py-3 px-6 rounded-lg text-white font-medium">
                    <i class="fa fa-database mr-2"></i>加载已保存单词
                </button>
            </div>
            
            <div id="file-upload-status" class="mt-6 hidden"></div>
            <div id="file-upload-error" class="mt-6 text-red-400 hidden"></div>
        </div>

        <!-- 游戏界面（默认隐藏） -->
        <div id="game-section" class="hidden w-full">
            <h1 class="text-3xl font-bold mb-8 text-center text-cyan-300">
                <i class="fa fa-puzzle-piece mr-2"></i>配对挑战
            </h1>
            
            <div class="flex flex-col md:flex-row gap-8 w-full">
                <div class="column flex-1 flex flex-col gap-3" id="left-column"></div>
                <div class="column flex-1 flex flex-col gap-3" id="right-column"></div>
            </div>
            
            <div id="status" class="mt-8 text-lg font-medium text-center"></div>
            <div id="progress" class="mt-4 text-sm text-center text-gray-300"></div>
            <div id="error" class="mt-4 text-red-400 text-center hidden"></div>
            
           
        </div>

        <!-- 错题统计界面（默认隐藏） -->
        <div id="error-summary-section" class="hidden w-full p-6 bg-slate-800 rounded-lg shadow-xl mt-8">
            <h2 class="text-2xl font-bold mb-6 text-center text-cyan-300">
                <i class="fa fa-bar-chart mr-2"></i>练习总结
            </h2>
            
            <div id="summary-stats" class="mb-8 text-center"></div>
            
            <div id="no-errors-message" class="text-center text-emerald-400 text-lg hidden">
                <i class="fa fa-check-circle mr-2"></i>恭喜！您没有错题！
            </div>
            
            <div id="errors-list-container" class="hidden">
                <h3 class="text-xl font-semibold mb-4 text-amber-300 border-b border-amber-500 pb-2">
                    错题记录
                </h3>
                <div id="errors-list" class="space-y-4 max-h-96 overflow-y-auto pr-2"></div>
            </div>
            
            <div class="mt-8 text-center">
                <button id="restart-button" class="bg-emerald-600 hover:bg-emerald-500 transition-all duration-300 py-3 px-8 rounded-lg text-white font-medium hidden">
                    <i class="fa fa-refresh mr-2"></i>重新开始
                </button>
                <button id="review-errors-button" class="bg-amber-600 hover:bg-amber-500 transition-all duration-300 py-3 px-8 rounded-lg text-white font-medium hidden">
                    <i class="fa fa-repeat mr-2"></i>复习错题
                </button>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let dataArray = [];           // 所有数据（从数据库获取）
        let currentItems = [];        // 当前轮次的题目
        let usedItems = new Set();    // 已经使用过的项目ID
        let currentRoundWrongItems = new Set(); // 本轮出现的错题
        let allTimeWrongItems = new Map(); // 所有时间的错题及错误次数 (id => count)
        let allItemsProcessed = false;// 所有项目是否已处理完毕
        let inReviewMode = false;     // 是否处于错题复习模式
        let clickHistory = [];        // 记录点击历史
        let matchedPairs = 0;         // 当前轮次已匹配的对数
        let totalItemsCount = 0;      // 总项目数量
        const ITEMS_PER_ROUND = 4;    // 每页显示4对题目

        // Supabase 配置
        const supabaseUrl = 'https://bsmitevfaqwdzlejxtmf.supabase.co';
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJzbWl0ZXZmYXF3ZHpsZWp4dG1mIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU3NzA4MTAsImV4cCI6MjA3MTM0NjgxMH0.r6DW0xfXUJPBuSyWu8xCDgsPLkRIT0zVFoxfgzfvh6I';

        // 创建 Supabase 客户端
        const supabase = createClient(supabaseUrl, supabaseAnonKey);

        // 事件监听
        document.getElementById('file-upload').addEventListener('change', handleFileUpload);
        document.getElementById('restart-button').addEventListener('click', restartGame);
        document.getElementById('review-errors-button').addEventListener('click', reviewErrors);
        document.getElementById('load-saved-words').addEventListener('click', loadSavedWords);

        // 页面加载完成后自动加载默认的1.csv文件
        window.addEventListener('load', loadDefaultCsv);

        // 加载默认CSV文件（public目录下的1.csv）
        async function loadDefaultCsv() {
            try {
                // 1. 从服务器获取默认的1.csv文件
                const response = await fetch('/1.csv');
                if (!response.ok) {
                    throw new Error(`文件加载失败: ${response.statusText}`);
                }
                
                const content = await response.text();
                let words = parseCsvData(content);
                
                // 2. 将CSV数据导入Supabase数据库
                await importWordsToSupabase(words, true); // append=true 表示追加
                
                // 3. 从Supabase获取完整的数据（包含新导入的和旧有的）
                dataArray = await getWordsFromSupabase();
                totalItemsCount = dataArray.length;
                
                // 4. 排序并开始游戏
                sortAndStartGame();
            } catch (error) {
                document.getElementById('file-upload-section').classList.remove('hidden');
                showFileError(`初始化失败: ${error.message}`);
                console.error('默认CSV加载失败:', error);
            }
        }

        // 加载已保存的单词
        async function loadSavedWords() {
            try {
                showFileStatus('正在从数据库加载单词...');
                dataArray = await getWordsFromSupabase();
                totalItemsCount = dataArray.length;
                
                if (dataArray.length === 0) {
                    showFileError('数据库中没有单词数据，请先上传CSV文件');
                    return;
                }
                
                sortAndStartGame();
            } catch (error) {
                showFileError(`加载失败: ${error.message}`);
            }
        }

        // 处理文件上传并导入Supabase
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // 验证文件类型
            if (!file.name.endsWith('.csv')) {
                showFileError('请选择CSV格式的文件');
                return;
            }

            // 读取文件
            const reader = new FileReader();
            showFileStatus('正在读取文件...');

            reader.onload = async function(e) {
                try {
                    const content = e.target.result;
                    const words = parseCsvData(content);
                    
                    // 导入数据库（采用追加模式）
                    showFileStatus('正在导入数据库...');
                    await importWordsToSupabase(words, true); // append=true 表示追加
                    
                    // 重新加载所有数据
                    dataArray = await getWordsFromSupabase();
                    totalItemsCount = dataArray.length;
                    
                    showFileStatus('文件导入成功，正在准备游戏...');
                    setTimeout(() => {
                        document.getElementById('file-upload-section').classList.add('hidden');
                        document.getElementById('game-section').classList.remove('hidden');
                        startNewRound();
                    }, 1000);
                } catch (error) {
                    showFileError(`文件处理错误: ${error.message}`);
                }
            };

            reader.onerror = function() {
                showFileError('文件读取失败，请重试');
            };

            reader.readAsText(file);
        }

        // 解析CSV数据
        function parseCsvData(content) {
            const words = [];
            const lines = content.trim().split('\n');
            
            if (lines.length === 0) {
                throw new Error('文件内容为空');
            }

            lines.forEach((line, index) => {
                const parts = line.trim().split(',').map(part => part.trim());
                if (parts.length < 2) {
                    throw new Error(`第${index + 1}行格式错误，需要至少两列数据`);
                }
                
                const left = parts[0];
                const right = parts.slice(1).join(','); // 允许右侧内容包含逗号
                const id = generateId(left, right);
                
                words.push({ id, left, right });
            });

            if (words.length === 0) {
                throw new Error('未找到有效的数据，请检查文件格式');
            }

            return words;
        }

        // 生成唯一ID用于跟踪项目
        function generateId(left, right) {
            return `${left}|${right}`;
        }

        // 显示文件上传状态
        function showFileStatus(message) {
            const statusEl = document.getElementById('file-upload-status');
            const errorEl = document.getElementById('file-upload-error');
            
            statusEl.textContent = message;
            statusEl.classList.remove('hidden', 'text-red-400');
            statusEl.classList.add('text-emerald-400');
            errorEl.classList.add('hidden');
        }

        // 显示文件上传错误
        function showFileError(message) {
            const statusEl = document.getElementById('file-upload-status');
            const errorEl = document.getElementById('file-upload-error');
            
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            statusEl.classList.add('hidden');
            
            // 重置文件输入，允许重新选择同一文件
            document.getElementById('file-upload').value = '';
        }

        // 重新开始游戏
        function restartGame() {
            // 重置所有游戏状态
            window.location.reload();
        }

        // 复习错题
        function reviewErrors() {
            // 重置当前轮次状态，但保留所有错题记录
            currentRoundWrongItems = new Set();
            currentItems = [];
            matchedPairs = 0;
            inReviewMode = true; // 强制进入错题复习模式
            
            // 隐藏总结界面，显示游戏界面
            document.getElementById('error-summary-section').classList.add('hidden');
            document.getElementById('game-section').classList.remove('hidden');
            
            // 开始新一轮（错题复习）
            startNewRound();
        }

        // 将单词数据导入Supabase
        async function importWordsToSupabase(words, append = false) {
            // 为了简化逻辑，我们直接插入或更新数据。如果ID已存在，则更新；否则插入。
            // 我们会为每个单词创建一个唯一的id。
            const upsertData = words.map(word => ({
                id: word.id,
                left: word.left,
                right: word.right,
                practice_count: 0,
                error_count: 0,
                error_rate: 0,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            }));

            // 使用supabase.table('words').upsert()来批量插入/更新
            const { data, error } = await supabase
                .from('words')
                .upsert(upsertData, { onConflict: 'id' }); // onConflict: 'id' 表示如果id已存在，则更新该行

            if (error) {
                throw new Error(`导入失败: ${error.message}`);
            }
        }

        // 从Supabase获取所有单词数据
        async function getWordsFromSupabase() {
            const { data, error } = await supabase
                .from('words')
                .select('*')
                .order('created_at', { ascending: false }); // 按创建日期倒序排列

            if (error) {
                throw new Error(`获取数据失败: ${error.message}`);
            }

            return data;
        }

        // 更新单词练习数据到Supabase
        async function updateWordStats(id, isCorrect) {
            try {
                // 获取当前单词的统计数据
                const { data: wordData, error: getError } = await supabase
                    .from('words')
                    .select('practice_count, error_count, error_rate')
                    .eq('id', id)
                    .single();

                if (getError) throw new Error(`获取单词数据失败: ${getError.message}`);

                // 计算新的统计数据
                const newPracticeCount = wordData.practice_count + 1;
                const newErrorCount = isCorrect ? wordData.error_count : wordData.error_count + 1;
                const newErrorRate = newPracticeCount > 0 ? (newErrorCount / newPracticeCount) * 100 : 0;

                // 更新数据库
                const { error: updateError } = await supabase
                    .from('words')
                    .update({
                        practice_count: newPracticeCount,
                        error_count: newErrorCount,
                        error_rate: newErrorRate,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', id);

                if (updateError) throw new Error(`更新数据失败: ${updateError.message}`);

                // 更新本地缓存
                const localWord = dataArray.find(w => w.id === id);
                if (localWord) {
                    localWord.practice_count = newPracticeCount;
                    localWord.error_count = newErrorCount;
                    localWord.error_rate = newErrorRate;
                    localWord.updated_at = new Date().toISOString();
                }

                // 由于我们只更新了一个单词，不需要全局刷新，所以不调用updateGlobalStats()
            } catch (error) {
                console.error('更新单词统计失败:', error);
                showError('数据同步失败，请重试');
            }
        }

        // 开始新一轮游戏
        function startNewRound() {
            const leftColumn = document.getElementById('left-column');
            const rightColumn = document.getElementById('right-column');
            
            // 重置当前轮次状态，但保留上一轮的错题
            const previousWrongItems = new Set(currentRoundWrongItems);
            currentRoundWrongItems.clear();
            
            leftColumn.innerHTML = '';
            rightColumn.innerHTML = '';
            clickHistory = [];
            matchedPairs = 0;
            currentItems = [];

            // 检查是否所有题目都已处理完毕且没有错题
            if (usedItems.size >= totalItemsCount && !inReviewMode && previousWrongItems.size === 0) {
                showErrorSummary();
                return;
            }

            // 检查是否需要进入错题复习模式
            if (usedItems.size >= totalItemsCount && !inReviewMode) {
                inReviewMode = true;
                usedItems.clear(); // 重置已使用项目，只复习错题
                updateStatus('所有题目已完成，进入错题复习模式...');
            }

            // 获取当前轮次要使用的项目（包含上一轮的错题）
            getCurrentRoundItems(previousWrongItems);
            
            // 如果当前轮次没有题目，说明所有内容已完成
            if (currentItems.length === 0) {
                showErrorSummary();
                return;
            }
            
            // 生成左侧按钮
            currentItems.forEach(item => {
                const button = createButton(item.left, 'left', item.right, item.id);
                leftColumn.appendChild(button);
            });

            // 生成右侧按钮（确保不会与左侧同位置按钮匹配，除非只有一道题）
            let rightItems;
            if (currentItems.length === 1) {
                // 最后一轮只有一道题时，直接使用
                rightItems = [...currentItems];
            } else {
                // 否则，生成不会与左侧同位置匹配的排列
                rightItems = generateNonMatchingRightItems([...currentItems]);
            }
            
            rightItems.forEach(item => {
                const button = createButton(item.right, 'right', item.right, item.id);
                rightColumn.appendChild(button);
            });

            // 更新进度显示
            updateProgress(previousWrongItems);
            updateStatus(inReviewMode
                ? `错题复习: ${matchedPairs} / ${currentItems.length} 对`
                : `当前轮次: ${matchedPairs} / ${currentItems.length} 对`);
        }

        // 创建按钮元素
        function createButton(text, side, value, id) {
            const button = document.createElement('button');
            button.className = 'bg-slate-700 hover:bg-slate-600 transition-all duration-300 py-4 px-6 rounded-lg text-left text-lg font-medium';
            button.textContent = text;
            button.dataset.side = side;
            button.dataset.value = value;
            button.dataset.id = id;
            
            button.addEventListener('click', () => handleButtonClick(button));
            return button;
        }

        // 处理按钮点击
        async function handleButtonClick(button) {
            // 如果按钮已禁用，不处理点击
            if (button.classList.contains('btn-disabled')) return;
            
            // 如果已经选择了两个按钮，不处理新点击
            if (clickHistory.length >= 2) return;
            
            // 添加选中状态
            button.classList.add('btn-selected');
            clickHistory.push(button);
            
            // 如果选择了两个按钮，检查是否匹配
            if (clickHistory.length === 2) {
                const [first, second] = clickHistory;
                
                // 确保选择了左右各一个按钮
                if (first.dataset.side === second.dataset.side) {
                    // 取消选择
                    first.classList.remove('btn-selected');
                    second.classList.remove('btn-selected');
                    clickHistory = [];
                    showError('请选择左侧和右侧各一个选项');
                    return;
                }
                
                // 禁用所有按钮
                disableAllButtons();
                
                // 确定哪一个是左侧，哪一个是右侧
                const leftButton = first.dataset.side === 'left' ? first : second;
                const rightButton = first.dataset.side === 'right' ? first : second;
                const isMatch = leftButton.dataset.id === rightButton.dataset.id;
                
                if (isMatch) {
                    // 匹配成功
                    setTimeout(() => {
                        leftButton.classList.remove('btn-selected');
                        rightButton.classList.remove('btn-selected');
                        leftButton.classList.add('btn-disabled', 'strikethrough');
                        rightButton.classList.add('btn-disabled', 'strikethrough');
                        
                        // 更新匹配计数
                        matchedPairs++;
                        updateStatus(inReviewMode
                            ? `错题复习: ${matchedPairs} / ${currentItems.length} 对`
                            : `当前轮次: ${matchedPairs} / ${currentItems.length} 对`);
                        
                        // 记录已使用的项目
                        usedItems.add(leftButton.dataset.id);
                        
                        // 更新数据库（正确匹配）
                        updateWordStats(leftButton.dataset.id, true);
                        
                        // 检查是否完成当前轮次
                        if (matchedPairs >= currentItems.length) {
                            setTimeout(startNewRound, 100);
                        } else {
                            enableUnmatchedButtons();
                        }
                        
                        clickHistory = [];
                    }, 200);
                } else {
                    // 匹配失败
                    first.classList.add('btn-error');
                    second.classList.add('btn-error');
                    
                    // 记录错误
                    const leftId = leftButton.dataset.id;
                    currentRoundWrongItems.add(leftId);
                    allTimeWrongItems.set(leftId, (allTimeWrongItems.get(leftId) || 0) + 1);
                    
                    // 更新数据库（错误匹配）
                    updateWordStats(leftId, false);
                    
                    setTimeout(() => {
                        first.classList.remove('btn-selected', 'btn-error');
                        second.classList.remove('btn-selected', 'btn-error');
                        enableUnmatchedButtons();
                        clickHistory = [];
                    }, 1000);
                    
                    showError('匹配错误，请重试');
                }
            }
        }

        // 禁用所有按钮
        function disableAllButtons() {
            document.querySelectorAll('#left-column button, #right-column button').forEach(button => {
                button.disabled = true;
            });
        }

        // 启用未匹配的按钮
        function enableUnmatchedButtons() {
            document.querySelectorAll('#left-column button, #right-column button').forEach(button => {
                if (!button.classList.contains('btn-disabled')) {
                    button.disabled = false;
                }
            });
        }

        // 显示错题总结
        function showErrorSummary() {
            // 隐藏游戏界面，显示总结界面
            document.getElementById('game-section').classList.add('hidden');
            const summarySection = document.getElementById('error-summary-section');
            summarySection.classList.remove('hidden');

            // 计算统计数据
            const totalErrors = Array.from(allTimeWrongItems.values()).reduce((sum, count) => sum + count, 0);
            const uniqueErrors = allTimeWrongItems.size;

            // 更新统计信息
            const statsEl = document.getElementById('summary-stats');
            statsEl.innerHTML = `
                <p class="text-lg mb-2">总题目数量: <span class="text-cyan-300">${totalItemsCount}</span></p>
                <p class="text-lg mb-2">总错误次数: <span class="text-rose-300">${totalErrors}</span></p>
                <p class="text-lg">不同的错题数量: <span class="text-amber-300">${uniqueErrors}</span></p>
            `;

            // 显示或隐藏错题列表
            const noErrorsEl = document.getElementById('no-errors-message');
            const errorsContainerEl = document.getElementById('errors-list-container');
            const errorsListEl = document.getElementById('errors-list');
            const restartBtn = document.getElementById('restart-button');
            const reviewBtn = document.getElementById('review-errors-button');

            if (uniqueErrors === 0) {
                // 没有错题的情况
                noErrorsEl.classList.remove('hidden');
                errorsContainerEl.classList.add('hidden');
                restartBtn.classList.remove('hidden');
                reviewBtn.classList.add('hidden');
            } else {
                // 有错题的情况
                noErrorsEl.classList.add('hidden');
                errorsContainerEl.classList.remove('hidden');
                restartBtn.classList.add('hidden');
                reviewBtn.classList.remove('hidden');
                errorsListEl.innerHTML = '';

                // 按错误次数排序（从高到低）
                const sortedErrors = Array.from(allTimeWrongItems.entries())
                    .sort((a, b) => b[1] - a[1]);

                // 生成错题列表
                sortedErrors.forEach(([id, count]) => {
                    const item = dataArray.find(i => i.id === id);
                    if (item) {
                        const errorItem = document.createElement('div');
                        errorItem.className = 'bg-slate-700 p-4 rounded-lg shadow';
                        errorItem.innerHTML = `
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="font-medium"> <span class="text-cyan-300">${item.left}</span></p>
                                    <p class="mt-1"><span class="text-emerald-300">${item.right}</span></p>
                                </div>
                                <div class="bg-rose-600 text-white text-sm px-3 py-1 rounded-full">
                                    错误 ${count} 次
                                </div>
                            </div>
                        `;
                        errorsListEl.appendChild(errorItem);
                    }
                });
            }
        }

        // 生成右侧按钮数组，确保不会与左侧同位置匹配
        function generateNonMatchingRightItems(items) {
            let shuffled = [...items];
            
            // 检查随机排列是否存在同位置匹配
            function hasSamePositionMatches(arr) {
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i].id === items[i].id) {
                        return true;
                    }
                }
                return false;
            }
            
            // 随机法：随机打乱，直到不存在同位置匹配，或尝试次数过多则强制调整
            let attempts = 0;
            while (hasSamePositionMatches(shuffled) && attempts < 100) {
                shuffled = shuffled.sort(() => Math.random() - 0.5);
                attempts++;
            }
            
            // 如果尝试多次后仍有同位置匹配，则手动调整
            if (hasSamePositionMatches(shuffled)) {
                for (let i = 0; i < shuffled.length; i++) {
                    if (shuffled[i].id === items[i].id) {
                        // 找到一个不同的位置进行交换
                        for (let j = 0; j < shuffled.length; j++) {
                            if (j !== i && shuffled[j].id !== items[i].id && shuffled[i].id !== items[j].id) {
                                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                                break;
                            }
                        }
                    }
                }
            }
            
            return shuffled;
        }

        // 获取当前轮次要使用的项目（包含上一轮的错题）
        function getCurrentRoundItems(previousWrongItems) {
            // 首先添加上一轮的所有错题（最高优先级）
            const wrongItemsArray = Array.from(previousWrongItems).map(id => {
                return dataArray.find(item => item.id === id);
            }).filter(Boolean); // 过滤可能的undefined

            wrongItemsArray.forEach(item => {
                if (!currentItems.some(i => i.id === item.id)) {
                    currentItems.push(item);
                }
            });

            // 筛选出错误率>10%的单词（与排序逻辑保持一致）
            const highErrorRateItems = dataArray.filter(item => {
                return item.error_rate > 10 &&  // 改为>10，匹配排序逻辑
                       !usedItems.has(item.id) &&
                       !currentItems.some(i => i.id === item.id);
            });

            // 随机排序高错误率单词（保持随机性）
            highErrorRateItems.sort(() => Math.random() - 0.5);

            // 处理复习模式
            if (inReviewMode) {
                // 从所有错题中选择，优先高错误率的
                const allWrongItems = Array.from(allTimeWrongItems.keys())
                    .map(id => dataArray.find(item => item.id === id))
                    .filter(Boolean);
                
                // 优先高错误率错题，再补充其他错题
                const prioritizedWrongItems = [
                    ...highErrorRateItems.filter(item => allWrongItems.some(i => i.id === item.id)),
                    ...allWrongItems.filter(item => !highErrorRateItems.some(i => i.id === item.id))
                ];
                
                const remainingSlots = ITEMS_PER_ROUND - currentItems.length;
                if (remainingSlots > 0) {
                    const availableItems = prioritizedWrongItems.filter(item =>
                        !currentItems.some(i => i.id === item.id)
                    );
                    
                    const itemsToAdd = Math.min(remainingSlots, availableItems.length);
                    currentItems.push(...availableItems.slice(0, itemsToAdd));
                }
            } else {
                // 正常模式：优先添加高错误率单词，再补充其他单词
                let remainingSlots = ITEMS_PER_ROUND - currentItems.length;
                
                // 先添加高错误率单词（错误率>10%）
                if (remainingSlots > 0 && highErrorRateItems.length > 0) {
                    const itemsToAdd = Math.min(remainingSlots, highErrorRateItems.length);
                    currentItems.push(...highErrorRateItems.slice(0, itemsToAdd));
                    remainingSlots -= itemsToAdd;
                }
                
                // 再添加其他未使用的单词（错误率≤10%）
                if (remainingSlots > 0) {
                    const availableItems = dataArray.filter(item =>
                        !usedItems.has(item.id) &&
                        !currentItems.some(i => i.id === item.id) &&
                        item.error_rate <= 10  // 只添加低错误率单词
                    );
                    
                    // 按排序后的顺序选取（保持原排序逻辑）
                    const itemsToAdd = Math.min(remainingSlots, availableItems.length);
                    currentItems.push(...availableItems.slice(0, itemsToAdd));
                }
            }
        }

        // 更新状态显示
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // 更新进度显示
        function updateProgress(previousWrongItems) {
            if (inReviewMode) {
                const totalWrongItems = allTimeWrongItems.size;
                document.getElementById('progress').textContent =
                    `错题复习进度: ${Math.min(usedItems.size, totalWrongItems)}/${totalWrongItems}`;
            } else {
                document.getElementById('progress').textContent =
                    `总体进度: ${Math.min(usedItems.size, totalItemsCount)}/${totalItemsCount}`;
            }
        }

        // 显示错误信息
        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => {
                errorEl.classList.add('hidden');
            }, 3000);
        }

        // 根据排序规则对数据进行排序并开始游戏
        function sortAndStartGame() {
            // 关键修改：按新规则排序
            dataArray.sort((a, b) => {
                // 1. 优先级第一：错误率>10%的单词排在前面，并随机排序
                if (a.error_rate > 10 && b.error_rate <= 10) return -1;
                if (a.error_rate <= 10 && b.error_rate > 10) return 1;
                
                // 2. 都是错误率>10%的单词，随机排序
                if (a.error_rate > 10 && b.error_rate > 10) {
                    return Math.random() - 0.5;
                }
                
                // 3. 优先级第二：错误率都≤10%的单词，按创建日期从近到远排序
                const aDate = new Date(a.created_at);
                const bDate = new Date(b.created_at);
                
                // 比较日期（只比较年月日，忽略时分秒）
                const aDateOnly = new Date(aDate.getFullYear(), aDate.getMonth(), aDate.getDate());
                const bDateOnly = new Date(bDate.getFullYear(), bDate.getMonth(), bDate.getDate());
                
                if (aDateOnly > bDateOnly) return -1; // a更新，排在前面
                if (aDateOnly < bDateOnly) return 1;  // b更新，排在前面
                
                // 4. 同一日期创建的单词，随机排序
                return Math.random() - 0.5;
            });
            
            // 开始游戏
            document.getElementById('file-upload-section').classList.add('hidden');
            document.getElementById('game-section').classList.remove('hidden');
            startNewRound();
        }

        // 创建 Supabase 客户端函数
        function createClient(url, key) {
            // 这是一个模拟的createClient函数，因为标准的Supabase客户端是通过npm安装的。
            // 在实际的浏览器环境中，您需要通过<script>标签引入Supabase客户端，或者使用ES6模块。
            // 这里我们提供一个基于fetch的简易实现。
            return {
                from: (table) => ({
                    select: (columns) => ({
                        single: () => ({ data: null, error: null }), // 模拟返回值
                        order: (column, options) => ({
                            single: () => ({ data: null, error: null }) // 模拟返回值
                        }),
                        eq: (column, value) => ({
                            single: () => ({ data: null, error: null }) // 模拟返回值
                        })
                    }),
                    insert: (data) => ({
                        data: data,
                        error: null
                    }),
                    update: (data) => ({
                        data: data,
                        error: null
                    }),
                    upsert: (data, options) => ({
                        data: data,
                        error: null
                    })
                })
            };
        }
    </script>
</body>
</html>
