<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配对挑战 - 带数据统计</title>
    <!-- 1. 移除了 script 标签 URL 末尾的空格 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- 2. 配置 Tailwind CSS 以处理自定义工具类 -->
    <script>
        tailwind.config = {
            // 如果需要自定义主题，可以在这里添加
            // theme: { extend: { ... } },
            // plugins: [] // 如果有插件，可以在这里添加
        }
    </script>

    <style type="text/tailwindcss">
        @layer utilities {
            .btn-selected {
                @apply bg-emerald-500 transform scale-105;
            }
            .btn-disabled {
                @apply bg-gray-500 opacity-50 cursor-not-allowed;
            }
            .strikethrough {
                text-decoration: line-through;
            }
            .btn-error {
                @apply bg-rose-500;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 to-slate-800 min-h-screen flex flex-col items-center justify-center p-4 text-white">
    <!-- 主容器 -->
    <div class="max-w-4xl w-full mx-auto flex flex-col items-center">
        <!-- 文件选择界面 -->
        <div id="file-upload-section" class="text-center p-8 w-full">
            <h1 class="text-3xl font-bold mb-8 text-cyan-300">
                <i class="fa fa-puzzle-piece mr-2"></i>配对挑战
            </h1>
            <p class="text-gray-300 mb-6 text-lg">请选择一个CSV格式文件开始游戏（每行包含两列，用逗号分隔）</p>

            <label for="file-upload" class="cursor-pointer inline-block">
                <div class="bg-slate-700 hover:bg-emerald-600 transition-all duration-300 py-6 px-10 rounded-lg shadow-lg inline-flex items-center justify-center">
                    <i class="fa fa-file-text-o mr-3 text-xl"></i>
                    <span class="text-lg font-medium">选择CSV文件</span>
                </div>
                <input id="file-upload" type="file" accept="text/csv" class="hidden">
            </label>

            <div class="mt-6 flex justify-center gap-4">
                <button id="load-saved-words" class="bg-blue-600 hover:bg-blue-500 transition-all duration-300 py-3 px-6 rounded-lg text-white font-medium">
                    <i class="fa fa-database mr-2"></i>加载已保存单词
                </button>
                <!-- 移除重置统计数据按钮 -->
            </div>

            <div id="file-upload-status" class="mt-6 hidden"></div>
            <div id="file-upload-error" class="mt-6 text-red-400 hidden"></div>
        </div>

        <!-- 游戏界面（默认隐藏） -->
        <div id="game-section" class="hidden w-full">
            <h1 class="text-3xl font-bold mb-8 text-center text-cyan-300">
                <i class="fa fa-puzzle-piece mr-2"></i>配对挑战
            </h1>

            <div class="flex flex-col md:flex-row gap-8 w-full">
                <div class="column flex-1 flex flex-col gap-3" id="left-column"></div>
                <div class="column flex-1 flex flex-col gap-3" id="right-column"></div>
            </div>

            <div id="status" class="mt-8 text-lg font-medium text-center"></div>
            <div id="progress" class="mt-4 text-sm text-center text-gray-300"></div>
            <div id="error" class="mt-4 text-red-400 text-center hidden"></div>

        </div>

        <!-- 错题统计界面（默认隐藏） -->
        <div id="error-summary-section" class="hidden w-full p-6 bg-slate-800 rounded-lg shadow-xl mt-8">
            <h2 class="text-2xl font-bold mb-6 text-center text-cyan-300">
                <i class="fa fa-bar-chart mr-2"></i>练习总结
            </h2>
            <!-- 在文件上传区域或游戏区域添加 -->
            <div id="global-stats" class="mt-4 text-center text-sm text-gray-400">
                总练习: <span id="total-practice">0</span> |
                总错误: <span id="total-errors">0</span> |
                平均错误率: <span id="average-error-rate">0%</span>
            </div>
            <div id="summary-stats" class="mb-8 text-center"></div>

            <div id="no-errors-message" class="text-center text-emerald-400 text-lg hidden">
                <i class="fa fa-check-circle mr-2"></i>恭喜！您没有错题！
            </div>

            <div id="errors-list-container" class="hidden">
                <h3 class="text-xl font-semibold mb-4 text-amber-300 border-b border-amber-500 pb-2">
                    错题记录
                </h3>
                <div id="errors-list" class="space-y-4 max-h-96 overflow-y-auto pr-2"></div>
            </div>

            <div class="mt-8 text-center">
                <button id="restart-button" class="bg-emerald-600 hover:bg-emerald-500 transition-all duration-300 py-3 px-8 rounded-lg text-white font-medium hidden">
                    <i class="fa fa-refresh mr-2"></i>重新开始
                </button>
                <button id="review-errors-button" class="bg-amber-600 hover:bg-amber-500 transition-all duration-300 py-3 px-8 rounded-lg text-white font-medium hidden">
                    <i class="fa fa-repeat mr-2"></i>复习错题
                </button>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let dataArray = [];           // 所有数据（从数据库获取）
        let currentItems = [];        // 当前轮次的题目
        let usedItems = new Set();    // 已经使用过的项目ID
        let currentRoundWrongItems = new Set(); // 本轮出现的错题
        let allTimeWrongItems = new Map(); // 所有时间的错题及错误次数 (id => count)
        let allItemsProcessed = false;// 所有项目是否已处理完毕
        let inReviewMode = false;     // 是否处于错题复习模式
        let clickHistory = [];        // 记录点击历史
        let matchedPairs = 0;         // 当前轮次已匹配的对数
        let totalItemsCount = 0;      // 总项目数量
        const ITEMS_PER_ROUND = 4;    // 每页显示4对题目
        const API_BASE_URL = 'http://localhost:3000/api';

        // 3. 将 Supabase 客户端初始化移到所有函数定义之前
        // 从 Supabase 项目设置中获取这些值
        const supabaseUrl = 'https://bsmitevfaqwdzlejxtmf.supabase.co'; // 移除了末尾空格
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJzbWl0ZXZmYXF3ZHpsZWp4dG1mIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU3NzA4MTAsImV4cCI6MjA3MTM0NjgxMH0.r6DW0xfXUJPBuSyWu8xCDgsPLkRIT0zVFoxfgzfvh6I';
        const supabase = supabase.createClient(supabaseUrl, supabaseKey); // 使用 supabase.createClient

        // 事件监听 (放在函数定义之后，确保函数存在)
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('file-upload').addEventListener('change', handleFileUpload);
            document.getElementById('restart-button').addEventListener('click', restartGame);
            document.getElementById('review-errors-button').addEventListener('click', reviewErrors);
            document.getElementById('load-saved-words').addEventListener('click', loadSavedWords);

            // 页面加载完成后自动加载 Supabase 数据
            loadSavedWords(); // 改为调用 loadSavedWords
        });


        // 修改 loadSavedWords 函数以直接从 Supabase 加载数据
        async function loadSavedWords() {
            try {
                showFileStatus('正在从 Supabase 数据库加载单词...');

                // --- 关键修改：使用 Supabase 客户端查询数据 ---
                // 注意：这里假设你的 Supabase 表名为 'words'
                // 注意：字段名 "left" 和 "right" 是保留字，需要用双引号括起来
                const { data, error } = await supabase
                    .from('words')
                    .select('"id", "left", "right", "practice_count", "error_count", "error_rate", "created_at"');

                if (error) throw error; // 如果查询出错，抛出异常

                let words = data; // 将获取到的数据赋值给 words 变量
                // --- 修改结束 ---

                if (words.length === 0) {
                    showFileError('数据库中没有单词数据');
                    // 如果你保留了文件上传功能，可以提示用户上传
                    // showFileError('数据库中没有单词数据，请先上传CSV文件');
                    document.getElementById('file-upload-section').classList.remove('hidden'); // 显示上传界面
                    return;
                }

                // 应用你已有的排序逻辑
                words.sort((a, b) => {
                    // 1. 优先级第一：错误率>10%的单词排在前面，并随机排序
                    if (a.error_rate > 10 && b.error_rate <= 10) return -1;
                    if (a.error_rate <= 10 && b.error_rate > 10) return 1;

                    // 2. 都是错误率>10%的单词，随机排序
                    if (a.error_rate > 10 && b.error_rate > 10) {
                        return Math.random() - 0.5;
                    }

                    // 3. 优先级第二：错误率都≤10%的单词，按创建日期从近到远排序
                    const aDate = new Date(a.created_at);
                    const bDate = new Date(b.created_at);

                    // 比较日期（只比较年月日，忽略时分秒）
                    const aDateOnly = new Date(aDate.getFullYear(), aDate.getMonth(), aDate.getDate());
                    const bDateOnly = new Date(bDate.getFullYear(), bDate.getMonth(), bDate.getDate());

                    if (aDateOnly > bDateOnly) return -1; // a更新，排在前面
                    if (aDateOnly < bDateOnly) return 1;  // b更新，排在前面

                    // 4. 同一日期创建的单词，随机排序
                    return Math.random() - 0.5;
                });

                dataArray = words;
                totalItemsCount = dataArray.length;

                showFileStatus('加载成功，正在准备游戏...');
                setTimeout(() => {
                    document.getElementById('file-upload-section').classList.add('hidden');
                    document.getElementById('game-section').classList.remove('hidden');
                    startNewRound();
                    updateGlobalStats(); // 这个函数也需要修改为使用 Supabase
                }, 1000);
            } catch (error) {
                console.error('从 Supabase 加载数据失败:', error);
                showFileError(`加载失败: ${error.message || error.details || '未知错误'}`);
                document.getElementById('file-upload-section').classList.remove('hidden'); // 出错时也显示上传界面
            }
        }

        // 修改 updateGlobalStats 函数以使用 Supabase 数据
        async function updateGlobalStats() {
            try {
                // --- 关键修改：从 Supabase 获取所有单词数据 ---
                const { data, error } = await supabase
                    .from('words')
                    .select('"practice_count", "error_count"'); // 只需要这两个字段用于统计

                if (error) throw error;
                // --- 修改结束 ---

                // 计算统计数据 (修复了缺失的逻辑)
                const totalPractice = data.reduce((sum, word) => sum + (word.practice_count || 0), 0);
                const totalErrors = data.reduce((sum, word) => sum + (word.error_count || 0), 0);
                const averageErrorRate = totalPractice > 0
                    ? ((totalErrors / totalPractice) * 100).toFixed(1)
                    : '0';

                // 更新页面上的统计显示元素
                const totalPracticeEl = document.getElementById('total-practice');
                const totalErrorsEl = document.getElementById('total-errors');
                const averageErrorRateEl = document.getElementById('average-error-rate');
                if (totalPracticeEl) totalPracticeEl.textContent = totalPractice;
                if (totalErrorsEl) totalErrorsEl.textContent = totalErrors;
                if (averageErrorRateEl) averageErrorRateEl.textContent = `${averageErrorRate}%`;

                console.log(`统计更新: 练习${totalPractice}, 错误${totalErrors}, 错误率${averageErrorRate}%`); // 临时日志

            } catch (error) {
                console.error('更新统计信息失败:', error);
                // showError('更新统计数据失败'); // 可选：显示错误提示
            }
        }


        // 修改 updateWordStats 函数以使用 Supabase 更新数据
        async function updateWordStats(id, isCorrect) {
            try {
                // 首先，获取当前单词的最新数据（practice_count, error_count）
                const { data: currentData, error: fetchError } = await supabase
                    .from('words')
                    .select('"practice_count", "error_count"')
                    .eq('id', id)
                    .single(); // 假设 id 是唯一的

                if (fetchError) throw fetchError;

                // 计算新的计数
                let newPracticeCount = (currentData.practice_count || 0) + 1;
                let newErrorCount = currentData.error_count || 0;
                if (!isCorrect) {
                    newErrorCount += 1;
                }
                let newErrorRate = newPracticeCount > 0 ? (newErrorCount / newPracticeCount) * 100 : 0;

                // --- 关键修改：使用 Supabase 更新记录 ---
                const { data, error } = await supabase
                    .from('words')
                    .update({
                        practice_count: newPracticeCount,
                        error_count: newErrorCount,
                        error_rate: newErrorRate,
                        updated_at: new Date() // 更新时间戳
                    })
                    .eq('id', id); // 根据 id 更新

                if (error) throw error;
                // --- 修改结束 ---

                console.log(`单词 ${id} 数据更新成功`);
                await updateGlobalStats(); // 更新全局统计
                // return data; // 如果需要返回更新后的数据
            } catch (error) {
                console.error('更新单词统计失败:', error);
                showError('数据同步失败，请重试');
            }
        }

        // 重新开始游戏
        function restartGame() {
            // 重置所有游戏状态
            window.location.reload();
        }

        // 复习错题
        function reviewErrors() {
            // 重置当前轮次状态，但保留所有错题记录
            currentRoundWrongItems = new Set();
            currentItems = [];
            matchedPairs = 0;
            inReviewMode = true; // 强制进入错题复习模式

            // 隐藏总结界面，显示游戏界面
            document.getElementById('error-summary-section').classList.add('hidden');
            document.getElementById('game-section').classList.remove('hidden');

            // 开始新一轮（错题复习）
            startNewRound();
        }

        // 处理文件上传并导入数据库
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // 验证文件类型
            if (!file.name.endsWith('.csv')) {
                showFileError('请选择CSV格式的文件');
                return;
            }

            // 读取文件
            const reader = new FileReader();
            showFileStatus('正在读取文件...');

            reader.onload = async function(e) {
                try {
                    const content = e.target.result;
                    const words = parseCsvData(content);

                    // 导入数据库（采用追加模式）
                    showFileStatus('正在导入数据库...');
                    const response = await fetch(`${API_BASE_URL}/words/import`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ words, append: true }) // 添加append参数确保不覆盖
                    });

                    if (!response.ok) throw new Error('导入数据库失败');

                    dataArray = words;
                    totalItemsCount = dataArray.length;

                    showFileStatus('文件导入成功，正在准备游戏...');
                    setTimeout(() => {
                        document.getElementById('file-upload-section').classList.add('hidden');
                        document.getElementById('game-section').classList.remove('hidden');
                        startNewRound();
                    }, 1000);
                } catch (error) {
                    showFileError(`文件处理错误: ${error.message}`);
                }
            };

            reader.onerror = function() {
                showFileError('文件读取失败，请重试');
            };

            reader.readAsText(file);
        }

        // 显示文件上传状态
        function showFileStatus(message) {
            const statusEl = document.getElementById('file-upload-status');
            const errorEl = document.getElementById('file-upload-error');

            statusEl.textContent = message;
            statusEl.classList.remove('hidden', 'text-red-400');
            statusEl.classList.add('text-emerald-400');
            errorEl.classList.add('hidden');
        }

        // 显示文件上传错误
        function showFileError(message) {
            const statusEl = document.getElementById('file-upload-status');
            const errorEl = document.getElementById('file-upload-error');

            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            statusEl.classList.add('hidden');

            // 重置文件输入，允许重新选择同一文件
            document.getElementById('file-upload').value = '';
        }

        // 解析CSV数据
        function parseCsvData(content) {
            const words = [];
            const lines = content.trim().split('\n');

            if (lines.length === 0) {
                throw new Error('文件内容为空');
            }

            lines.forEach((line, index) => {
                const parts = line.trim().split(',').map(part => part.trim());
                if (parts.length < 2) {
                    throw new Error(`第${index + 1}行格式错误，需要至少两列数据`);
                }

                const left = parts[0];
                const right = parts.slice(1).join(','); // 允许右侧内容包含逗号
                const id = generateId(left, right);

                words.push({ id, left, right });
            });

            if (words.length === 0) {
                throw new Error('未找到有效的数据，请检查文件格式');
            }

            return words;
        }

        // 生成唯一ID用于跟踪项目
        function generateId(left, right) {
            return `${left}|${right}`;
        }

        // 显示错误信息
        function showError(message) {
            const errorEl = document.getElementById('error');
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => {
                errorEl.classList.add('hidden');
            }, 3000);
        }


        // 开始新一轮游戏
        function startNewRound() {
            const leftColumn = document.getElementById('left-column');
            const rightColumn = document.getElementById('right-column');

            // 重置当前轮次状态，但保留上一轮的错题
            const previousWrongItems = new Set(currentRoundWrongItems);
            currentRoundWrongItems.clear();

            leftColumn.innerHTML = '';
            rightColumn.innerHTML = '';
            clickHistory = [];
            matchedPairs = 0;
            currentItems = [];

            // 检查是否所有题目都已处理完毕且没有错题
            if (usedItems.size >= totalItemsCount && !inReviewMode && previousWrongItems.size === 0) {
                showErrorSummary();
                return;
            }

            // 检查是否需要进入错题复习模式
            if (usedItems.size >= totalItemsCount && !inReviewMode) {
                inReviewMode = true;
                usedItems.clear(); // 重置已使用项目，只复习错题
                updateStatus('所有题目已完成，进入错题复习模式...');
            }

            // 获取当前轮次要使用的项目（包含上一轮的错题）
            getCurrentRoundItems(previousWrongItems);

            // 如果当前轮次没有题目，说明所有内容已完成
            if (currentItems.length === 0) {
                showErrorSummary();
                return;
            }

            // 生成左侧按钮
            currentItems.forEach(item => {
                const button = createButton(item.left, 'left', item.right, item.id);
                leftColumn.appendChild(button);
            });

            // 生成右侧按钮（确保不会与左侧同位置按钮匹配，除非只有一道题）
            let rightItems;
            if (currentItems.length === 1) {
                // 最后一轮只有一道题时，直接使用
                rightItems = [...currentItems];
            } else {
                // 否则，生成不会与左侧同位置匹配的排列
                rightItems = generateNonMatchingRightItems([...currentItems]);
            }

            rightItems.forEach(item => {
                const button = createButton(item.right, 'right', item.right, item.id);
                rightColumn.appendChild(button);
            });

            // 更新进度显示
            updateProgress(previousWrongItems);
            updateStatus(inReviewMode
                ? `错题复习: ${matchedPairs} / ${currentItems.length} 对`
                : `当前轮次: ${matchedPairs} / ${currentItems.length} 对`);
        }

        // 创建按钮元素
        function createButton(text, side, value, id) {
            const button = document.createElement('button');
            button.className = 'bg-slate-700 hover:bg-slate-600 transition-all duration-300 py-4 px-6 rounded-lg text-left text-lg font-medium';
            button.textContent = text;
            button.dataset.side = side;
            button.dataset.value = value;
            button.dataset.id = id;

            button.addEventListener('click', () => handleButtonClick(button));
            return button;
        }

        // 处理按钮点击
        async function handleButtonClick(button) {
            // 如果按钮已禁用，不处理点击
            if (button.classList.contains('btn-disabled')) return;

            // 如果已经选择了两个按钮，不处理新点击
            if (clickHistory.length >= 2) return;

            // 添加选中状态
            button.classList.add('btn-selected');
            clickHistory.push(button);

            // 如果选择了两个按钮，检查是否匹配
            if (clickHistory.length === 2) {
                const [first, second] = clickHistory;

                // 确保选择了左右各一个按钮
                if (first.dataset.side === second.dataset.side) {
                    // 取消选择
                    first.classList.remove('btn-selected');
                    second.classList.remove('btn-selected');
                    clickHistory = [];
                    showError('请选择左侧和右侧各一个选项');
                    return;
                }

                // 禁用所有按钮
                disableAllButtons();

                // 确定哪一个是左侧，哪一个是右侧
                const leftButton = first.dataset.side === 'left' ? first : second;
                const rightButton = first.dataset.side === 'right' ? first : second;
                const isMatch = leftButton.dataset.id === rightButton.dataset.id;

                if (isMatch) {
                    // 匹配成功
                    setTimeout(() => {
                        leftButton.classList.remove('btn-selected');
                        rightButton.classList.remove('btn-selected');
                        leftButton.classList.add('btn-disabled', 'strikethrough');
                        rightButton.classList.add('btn-disabled', 'strikethrough');

                        // 更新匹配计数
                        matchedPairs++;
                        updateStatus(inReviewMode
                            ? `错题复习: ${matchedPairs} / ${currentItems.length} 对`
                            : `当前轮次: ${matchedPairs} / ${currentItems.length} 对`);

                        // 记录已使用的项目
                        usedItems.add(leftButton.dataset.id);

                        // 更新数据库（正确匹配）
                        updateWordStats(leftButton.dataset.id, true);

                        // 检查是否完成当前轮次
                        if (matchedPairs >= currentItems.length) {
                            setTimeout(startNewRound, 100);
                        } else {
                            enableUnmatchedButtons();
                        }

                        clickHistory = [];
                    }, 200);
                } else {
                    // 匹配失败
                    first.classList.add('btn-error');
                    second.classList.add('btn-error');

                    // 记录错误
                    const leftId = leftButton.dataset.id;
                    currentRoundWrongItems.add(leftId);
                    allTimeWrongItems.set(leftId, (allTimeWrongItems.get(leftId) || 0) + 1);

                    // 更新数据库（错误匹配）
                    updateWordStats(leftId, false);

                    setTimeout(() => {
                        first.classList.remove('btn-selected', 'btn-error');
                        second.classList.remove('btn-selected', 'btn-error');
                        enableUnmatchedButtons();
                        clickHistory = [];
                    }, 1000);

                    showError('匹配错误，请重试');
                }
            }
        }

        // 禁用所有按钮
        function disableAllButtons() {
            document.querySelectorAll('#left-column button, #right-column button').forEach(button => {
                button.disabled = true;
            });
        }

        // 启用未匹配的按钮
        function enableUnmatchedButtons() {
            document.querySelectorAll('#left-column button, #right-column button').forEach(button => {
                if (!button.classList.contains('btn-disabled')) {
                    button.disabled = false;
                }
            });
        }

        // 显示错题总结
        function showErrorSummary() {
            // 隐藏游戏界面，显示总结界面
            document.getElementById('game-section').classList.add('hidden');
            const summarySection = document.getElementById('error-summary-section');
            summarySection.classList.remove('hidden');

            // 计算统计数据
            const totalErrors = Array.from(allTimeWrongItems.values()).reduce((sum, count) => sum + count, 0);
            const uniqueErrors = allTimeWrongItems.size;

            // 更新统计信息
            const statsEl = document.getElementById('summary-stats');
            statsEl.innerHTML = `
                <p class="text-lg mb-2">总题目数量: <span class="text-cyan-300">${totalItemsCount}</span></p>
                <p class="text-lg mb-2">总错误次数: <span class="text-rose-300">${totalErrors}</span></p>
                <p class="text-lg">不同的错题数量: <span class="text-amber-300">${uniqueErrors}</span></p>
            `;

            // 显示或隐藏错题列表
            const noErrorsEl = document.getElementById('no-errors-message');
            const errorsContainerEl = document.getElementById('errors-list-container');
            const errorsListEl = document.getElementById('errors-list');
            const restartBtn = document.getElementById('restart-button');
            const reviewBtn = document.getElementById('review-errors-button');

            if (uniqueErrors === 0) {
                // 没有错题的情况
                noErrorsEl.classList.remove('hidden');
                errorsContainerEl.classList.add('hidden');
                restartBtn.classList.remove('hidden');
                reviewBtn.classList.add('hidden');
            } else {
                // 有错题的情况
                noErrorsEl.classList.add('hidden');
                errorsContainerEl.classList.remove('hidden');
                restartBtn.classList.add('hidden');
                reviewBtn.classList.remove('hidden');
                errorsListEl.innerHTML = '';

                // 按错误次数排序（从高到低）
                const sortedErrors = Array.from(allTimeWrongItems.entries())
                    .sort((a, b) => b[1] - a[1]);

                // 生成错题列表
                sortedErrors.forEach(([id, count]) => {
                    const item = dataArray.find(i => i.id === id);
                    if (item) {
                        const errorItem = document.createElement('div');
                        errorItem.className = 'bg-slate-700 p-4 rounded-lg shadow';
                        errorItem.innerHTML = `
                            <div class="flex justify-between items-start">
                                <div>
                                    <p class="font-medium"> <span class="text-cyan-300">${item.left}</span></p>
                                    <p class="mt-1"><span class="text-emerald-300">${item.right}</span></p>
                                </div>
                                <div class="bg-rose-600 text-white text-sm px-3 py-1 rounded-full">
                                    错误 ${count} 次
                                </div>
                            </div>
                        `;
                        errorsListEl.appendChild(errorItem);
                    }
                });
            }
        }

        // 生成右侧按钮数组，确保不会与左侧同位置匹配
        function generateNonMatchingRightItems(items) {
            let shuffled = [...items];

            // 检查随机排列是否存在同位置匹配
            function hasSamePositionMatches(arr) {
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i].id === items[i].id) {
                        return true;
                    }
                }
                return false;
            }

            // 随机法：随机打乱，直到不存在同位置匹配，或尝试次数过多则强制调整
            let attempts = 0;
            while (hasSamePositionMatches(shuffled) && attempts < 100) {
                shuffled = shuffled.sort(() => Math.random() - 0.5);
                attempts++;
            }

            // 如果尝试多次后仍有同位置匹配，则手动调整
            if (hasSamePositionMatches(shuffled)) {
                for (let i = 0; i < shuffled.length; i++) {
                    if (shuffled[i].id === items[i].id) {
                        // 找到一个不同的位置进行交换
                        for (let j = 0; j < shuffled.length; j++) {
                            if (j !== i && shuffled[j].id !== items[i].id && shuffled[i].id !== items[j].id) {
                                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                                break;
                            }
                        }
                    }
                }
            }

            return shuffled;
        }

        // 获取当前轮次要使用的项目（包含上一轮的错题）
        // 修改getCurrentRoundItems函数，优先展示错误率大于90%的单词
        // 修改getCurrentRoundItems函数，统一高错误率判断标准为>10%
        function getCurrentRoundItems(previousWrongItems) {
            // 首先添加上一轮的所有错题（最高优先级）
            const wrongItemsArray = Array.from(previousWrongItems).map(id => {
                return dataArray.find(item => item.id === id);
            }).filter(Boolean); // 过滤可能的undefined

            wrongItemsArray.forEach(item => {
                if (!currentItems.some(i => i.id === item.id)) {
                    currentItems.push(item);
                }
            });

            // 筛选出错误率>10%的单词（与排序逻辑保持一致）
            const highErrorRateItems = dataArray.filter(item => {
                return item.error_rate > 10 &&  // 改为>10，匹配排序逻辑
                       !usedItems.has(item.id) &&
                       !currentItems.some(i => i.id === item.id);
            });

            // 随机排序高错误率单词（保持随机性）
            highErrorRateItems.sort(() => Math.random() - 0.5);

            // 处理复习模式
            if (inReviewMode) {
                // 从所有错题中选择，优先高错误率的
                const allWrongItems = Array.from(allTimeWrongItems.keys())
                    .map(id => dataArray.find(item => item.id === id))
                    .filter(Boolean);

                // 优先高错误率错题，再补充其他错题
                const prioritizedWrongItems = [
                    ...highErrorRateItems.filter(item => allWrongItems.some(i => i.id === item.id)),
                    ...allWrongItems.filter(item => !highErrorRateItems.some(i => i.id === item.id))
                ];

                const remainingSlots = ITEMS_PER_ROUND - currentItems.length;
                if (remainingSlots > 0) {
                    const availableItems = prioritizedWrongItems.filter(item =>
                        !currentItems.some(i => i.id === item.id)
                    );

                    const itemsToAdd = Math.min(remainingSlots, availableItems.length);
                    currentItems.push(...availableItems.slice(0, itemsToAdd));
                }
            } else {
                // 正常模式：优先添加高错误率单词，再补充其他单词
                let remainingSlots = ITEMS_PER_ROUND - currentItems.length;

                // 先添加高错误率单词（错误率>10%）
                if (remainingSlots > 0 && highErrorRateItems.length > 0) {
                    const itemsToAdd = Math.min(remainingSlots, highErrorRateItems.length);
                    currentItems.push(...highErrorRateItems.slice(0, itemsToAdd));
                    remainingSlots -= itemsToAdd;
                }

                // 再添加其他未使用的单词（错误率≤10%）
                if (remainingSlots > 0) {
                    const availableItems = dataArray.filter(item =>
                        !usedItems.has(item.id) &&
                        !currentItems.some(i => i.id === item.id) &&
                        item.error_rate <= 10  // 只添加低错误率单词
                    );

                    // 按排序后的顺序选取（保持原排序逻辑）
                    const itemsToAdd = Math.min(remainingSlots, availableItems.length);
                    currentItems.push(...availableItems.slice(0, itemsToAdd));
                }
            }
        }
        // 更新状态显示
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // 更新进度显示
        function updateProgress(previousWrongItems) {
            if (inReviewMode) {
                const totalWrongItems = allTimeWrongItems.size;
                document.getElementById('progress').textContent =
                    `错题复习进度: ${Math.min(usedItems.size, totalWrongItems)}/${totalWrongItems}`;
            } else {
                document.getElementById('progress').textContent =
                    `总体进度: ${Math.min(usedItems.size, totalItemsCount)}/${totalItemsCount}`;
            }
        }


    </script>
</body>
</html>
